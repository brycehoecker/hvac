// "@(#) Vcorba  1.5"
// DO NOT EDIT THIS FILE. It was generated on
// Fri Apr  8 11:32:49 IST 2005 from
// Vcorba.h.in - CORBA wrapper classes for VERITAS
//
// This works under omniORB4. Maybe it will work for others as well.
//
// Marty Olevitch, Feb '04
// marty@cosray.wustl.edu

// For detailed documentation, see the end of this file or see the doxygen
// files in docs/html/index.html, which is generated from this file.

#ifndef _VCORBA_H
#define _VCORBA_H

#include <iostream>
#include <string>
#include <sstream>

// exception.h - Filip Pizlo's VERITAS exception classes
#include "exception.h"

// CORBA.h - the main CORBA header file. At least for the default omniORB4
// installation, this will be in /usr/local/include/omniORB4. You should
// tell your compiler about it by saying -I/usr/local/include/omniORB4 or
// whatever the equivalent would be on your system.
#include <CORBA.h>
#include <qthread.h>

namespace Vcorba {

    // version()
    /** \brief Return the version information
     */
    std::string version();

    /** \brief VcorbaException
     *
     * all of the member functions of these classes
     * should throw only this exception, I hope.
     */
    class VcorbaException : public VException {
	public:
	    /** Sets the message using a \c std::string
	     */
	    VcorbaException(const std::string &message = "") {
		setStrings("VcorbaException", message);
	    }
    };

    /** \brief ostream operator<< for corba exceptions.
     *
     * From Henning and Vinoski, "Advanced CORBA Programming with C++", p. 321
     */
    std::ostream &operator<<(std::ostream& os, const CORBA::Exception& e);

    /** \brief Returns the text of the corba exception.
     */
    std::string string_from_corba_exception(CORBA::Exception &e);

    /** Values for timeout in corba_client::getObjectRef().
     */
    enum {
	/// Just try to get the object reference once; i.e. timeout = zero
	/// seconds.
	JUST_TRY_ONCE = 0,

	/// Never time out trying to get the object reference; i.e. timeout
	/// = infinity.
	NEVER_TIME_OUT = -1,
    };

    /** \brief corba_client class
     *
     * Used for programs that should be clients, that is, programs
     * programs that make corba calls in other programs. For a complete,
     * working example, see the file client.cpp in the Vcorba
     * distribution.
     */
     class corba_client {
	public:
	    /** corba_client constructor - initializes orb if necessary,
	     * gets reference to root context. Throws VcorbaException if
	     * any of these operations fail. If hostname is 0, uses the
	     * local nameserver, else the one on hostname.
	     */
	    corba_client(std::string& hostname) throw (VcorbaException);

	    /** Alternate corba_client constructor - uses caller-supplied
	     * argument vector.
	     */
	    corba_client(int& argc, char *argv[]) throw (VcorbaException);

	    /** corba_client::getObjectRef() - attempts to obtain an object
	     * reference. Will try once per second up to timeoutSec
	     * seconds. A zero value indicates to just try one time. A
	     * negative value indicates to try forever. If the time
	     * expires, then a VcorbaException is thrown.
	     */
	    CORBA::Object_var
		getObjectRef(const char* progName, const char *objName,
		    int timeoutSec)
		throw (VcorbaException);

#ifdef THIS_DOES_NOT_WORK
	    // But I wish it did work. See below.
	    template< typename T, typename T_var >
		T_var get_obj_ref(const char* progName, const char *objName)
		    throw (VcorbaException);
#endif

	private:
	    void client_init(int& argc, char *argv[]) throw (VcorbaException);
    };

    /** \brief corba_server class
     *
     * Used for programs that should be servers, that is, programs programs
     * that provide CORBA services to client programs. For a complete,
     * working example, see the file server.cpp in the Vcorba distribution.
     */
    class corba_server : public QThread {
	public:
	    /** corba_server constructor - initializes the orb, gets
	     * reference to root POA, and activates it. Throws a
	     * VcorbaException if any of these operations fail. If hostname
	     * is 0, uses the local nameserver, else the one on hostname.
	     */
	    corba_server(std::string& hostname) throw (VcorbaException);

	    /** Alternate corba_server constructor uses an argument vector
	     * provided by the caller.
	     */
	    corba_server(int& argc, char *argv[]) throw (VcorbaException);

	    /** destructor - destroys the orb.
	     */
	    ~corba_server();

	    /** activateAndRegister() - activates the servant, then
	     * registers it with the name service. Throws a VcorbaException
	     * if it receives an exception.
	     */
	    template < typename T >
		void activateAndRegister(T *serv, const char *progName,
		    const char *objName) throw (VcorbaException);
	    
	    /** registerObj() - registers an object with the name service.
	     */
	    void registerObj(CORBA::Object_var comms_obj, const char *progName,
		const char *objName) throw (VcorbaException);

	    /** corba_server::shutdown() - wraps a call to Orb->shutdown().
	     * Throws a VcorbaException if it receives an exception.
	     */
	    void shutdown(bool wait_for_completion) throw (VcorbaException);

        protected:
	    /** corba_server::run() - wraps a call to Orb->run(). Throws a
	     * VcorbaException if it receives an exception.
	     */
	    virtual void run() throw(VcorbaException);

	private:
	    void server_init(int& argc, char *argv[])
	    	throw (VcorbaException);
	    static PortableServer::POA_var Poa;
    };

    // Unfortunately, the template definitions have to be in the header
    // file. Our compiler doesn't yet support placing the definition in a
    // different translation unit. No 'export' keyword.

    template < typename T >
    void
    corba_server::activateAndRegister(T *serv, const char *progName,
	const char *objName) throw (VcorbaException)
    {
	try {
	    PortableServer::ObjectId_var serv_id = Poa->activate_object(serv);
	    CORBA::Object_var comms_obj = serv->_this();
	    registerObj(comms_obj, progName, objName);
	    serv->_remove_ref();
	} catch (CORBA::Exception &e) {
	    V_THROW(VcorbaException, string_from_corba_exception(e));
	} catch (VException &e) {
	    V_RETHROW(e);
	} catch (...) {
	    V_THROW(VcorbaException, "Mystery exception");
	}
    }

#ifdef THIS_DOES_NOT_WORK
    // This doesn't work when using, for example, Command and Command_var
    // and the T and T_var parameters. I am not sure why, but I think it is
    // because they are particularly hairy typedefs.
    template<typename T, typename T_var>
    T_var
    get_object_ref(const char* progName, const char *objName)
	throw (VcorbaException)
    {
	try {
	    CORBA::Object_var obj = getObjectRef(progName, objName);
	    T_var ref = T::_narrow(obj);
	    V_ASSERT(!CORBA::is_nil(ref));
	    return ref;
	} catch (VException &e) {
	    V_RETHROW(e);
	} catch (...) {
	    V_THROW(VcorbaException, "Mystery exception");
	}
    }
#endif	// THIS_DOES_NOT_WORK

}	// end of namespace Vcorba

/** \mainpage
 *
 * \author
 * 	Marty Olevitch \n
 * 	Physics Dept \n
 * 	Washington University in St Louis \n
 * 	marty at cosray dot wustl dot edu
 *
 * Vcorba provides some simple CORBA wrapper classes. It was originally
 * designed for use in the arrayctl program for the VERITAS gamma ray
 * telescope project.
 *
 * Everything is in namespace Vcorba.
 *
 * The classes provided are:
 * 	- \c Vcorba::corba_client
 * 	- \c Vcorba::corba_server
 * 	- \c Vcorba::VcorbaException
 *
 * <h3>Caveat</h3>
 * 
 *     These routines have been written with only a minimal understanding of
 *     how CORBA actually works. I have based their innards on looking at
 *     Glenn Sembroski's VCORBAHelper routines (although this work, Vcorba,
 *     is much simpler) and at Filip Pizlo's harvester code as well as a
 *     cursory reading of the Henning and Vinoski book. My motive in
 *     writing them is to avoid having a lot of messy CORBA code in my
 *     programs. Initially, I would have used VCORBAHelper, but it hadn't
 *     been updated to use omniORB4. But at this point, I think Vcorba is
 *     easier to use.
 * 
 * <h3>Demo code</h3>
 * 
 *     There is a sample client/server application in the "demo" directory.
 *     Run make in that directory to compile it. The client program is
 *     called \c client and the server is called \c server. Each of them
 *     takes one optional argument, a hostname to use as the corba
 *     nameserver. Not specifying a hostname means to use the localhost as
 *     the nameserver.
 * 
 * <h3>Compiling</h3>
 * 
 *     Run make. This should produce Vcorba.o and exception.o. Copy these
 *     files and Vcorba.h and exception.h to wherever is convenient for you.
 *     #include "Vcorba.h" and "exception.h" in your source code and link with
 *     the object files. Maybe eventually, these will be installed in a
 *     library in a standard location.
 *
 * <h3>Vcorba object references</h3>
 *
 *     Vcorba uses object references of the form
 *     <tt> VERITAS/program_name.Program/object_name.Object</tt>, for
 *     example <tt>VERITAS/arrayctl.Program/command.Object</tt>. This
 *     format is the standard for the VERITAS project. Probably, I should
 *     remove this restriction at some point. The two routines that
 *     manipulate the object references only accept as parameters the
 *     \c program_name and \c object_name. The rest of the name of the
 *     object reference is filled in internally to Vcorba.
 *
 * <h3>Exceptions</h3>
 * 
 *     I have tried to make all of the constructors and member functions
 *     throw only \c VcorbaExceptions. This inherits from Filip's
 *     VException. For the \c Vcorba calls, you should only have to be
 *     concerned about catching \c VcorbaExceptions. However, in clients,
 *     when actually making a CORBA call (ie:
 *     \c server_ref->steer_telescope()), that can throw other exceptions,
 *     including but not limited to \c CORBA::Exception and \c
 *     CosBlahBlahBlah::Exception, etc. See the code examples below.
 *
 * <h3> \c corba_client class</h3>
 * 
 *     This class is used for programs that should be clients, that is,
 *     programs that make corba calls in other programs. For a complete,
 *     working example, see the file client.cpp in the Vcorba
 *     distribution.
 * 
 *     The basic usage is:
 * 
 * \code
 * 	#include "Vcorba.h"
 * 	...
 * 	try {
 * 	    std::string hostname = "needlenose.wustl.edu";
 * 	    Vcorba::corba_client c(hostname);
 * \endcode
 * 
 *     This does the initial setting up of the client. After that, you
 *     should get a reference to a server object. For example, if the
 *     object is identified by <tt> VERITAS/Server.Program/Command.Object</tt>,
 *     then you would do the following:
 * 
 * \code
 * 	    Command_var server_ref;
 * 
 * 	    ...
 * 	
 * 	    CORBA::Object_var obj = c.getObjectRef("Server", "Command", 
 * 		NEVER_TIME_OUT);
 * 
 * 	    // Note: the following line may throw actual CORBA
 * 	    // exceptions.
 * 	    server_ref = Command::_narrow(obj);
 * 
 * 	    // You can now use server_ref to make function calls:
 * 	    server_ref->steer_telescope();
 * 
 * 	    ...
 * 
 * 	} catch (COBRA::Exception &e) {
 * 	    std::cerr
 * 		<< Vcorba::string_from_corba_exception(e) << std::endl;
 * 	    return 3;
 * 	} catch (VException &e) {
 * 	    // This clause will catch VcorbaExceptions, too.
 * 	    std::cerr << e << std::endl
 * 	    return 1;
 * 	} catch (...) {
 * 	    std::cerr << "Unknown exception." << std::endl;
 * 	    return 1;
 * 	}
 * 
 * 	return 0;
 * 	...
 * \endcode
 * 
 *     The last parameter of the \c getObjectRef() member function is a
 *     timeout value. You can give it a positive integer value \c N to cause
 *     it to wait N seconds before giving up on a connection. The enum
 *     value \c NEVER_TIME_OUT never times out, and \c JUST_TRY_ONCE just tries
 *     once, i.e. it has a timeout of zero seconds.

 * <h3> \c corba_server class</h3>
 * 
 *     This class should be used for servers, programs that provide CORBA
 *     services to clients. For a complete, working example see the file
 *     server.cpp in the Vcorba distribution.
 * 
 *     Using this class is also pretty simple. Start by instantiating a
 *     corba_server, creating a servant, activating and registering the
 *     servant, and then starting the CORBA event loop:
 * 
 * \code
 * 	#include "Vcorba.h"
 * 	...
 * 	Vcorba::corba_server *csp;
 * 
 * 	try {
 * 	    std::string hostname = "needlenose.wustl.edu";
 * 	    Vcorba::corba_server cs(hostname);
 *	    csp = &cs;
 * 
 * 	    // create servant
 * 	    Command_i *serv = new Command_i();
 * 
 * 	    csp->activateAndRegister(serv, "Server", "Command");
 * 
 * 	    // actually fire up CORBA
 * 	    csp->run();
 * 
 * 	    // The thread will block at this point. See below.
 * 
 * 	 } catch ....
 * \endcode
 * 
 *     To terminate the server part of your program, you will have to call
 *     the member function shutdown():
 * 
 * \code
 * 	csp->shutdown(false);
 * \endcode
 * 
 *     If the parameter is false, we don't wait for other CORBA threads to
 *     terminate. If true, then we do wait. After \c shutdown() returns, the
 *     CORBA event loop will terminate and we will return from the call to
 *     \c csp->run() above. When the corba_server object goes out of scope
 *     and is destructed, the CORBA \c destroy() call takes place.
 * 
 * <h3>operator<< for CORBA exceptions</h3>
 *
 *     There is an ostream \c operator<< for corba exceptions. It is taken
 *     from Henning and Vinoski, "Advanced CORBA Programming with C++", p. 321.
 *     Use it like so:
 * 
 * \code
 * 	    ...
 * 	    catch (CORBA::Exception &e) {
 * 	        std::cout << e << std::endl;
 * 	    }
 * 	    ...
 * \endcode
 * 
 * 	which will print something like:
 * 
 * \code
 * 	    CORBA::Exception COMM_FAILURE
 * 	     (can't contact object; maybe nameserver unavailable).
 * \endcode
 */

#endif // _VCORBA_H
