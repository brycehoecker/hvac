// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __VNETFunctions_hh__
#define __VNETFunctions_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_VNETFunctions
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_VNETFunctions
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_VNETFunctions
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE VHVCommunications

_CORBA_MODULE_BEG

  class VHVFloatSeq_var;

  class VHVFloatSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 >  {
  public:
    typedef VHVFloatSeq_var _var_type;
    inline VHVFloatSeq() {}
    inline VHVFloatSeq(const VHVFloatSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_s) {}

    inline VHVFloatSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max) {}
    inline VHVFloatSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Float* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline VHVFloatSeq& operator = (const VHVFloatSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class VHVFloatSeq_out;

  class VHVFloatSeq_var {
  public:
    inline VHVFloatSeq_var() : _pd_seq(0) {}
    inline VHVFloatSeq_var(VHVFloatSeq* _s) : _pd_seq(_s) {}
    inline VHVFloatSeq_var(const VHVFloatSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new VHVFloatSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~VHVFloatSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline VHVFloatSeq_var& operator = (VHVFloatSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline VHVFloatSeq_var& operator = (const VHVFloatSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new VHVFloatSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Float& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline VHVFloatSeq* operator -> () { return _pd_seq; }
    inline const VHVFloatSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator VHVFloatSeq& () const { return *_pd_seq; }
#else
    inline operator const VHVFloatSeq& () const { return *_pd_seq; }
    inline operator VHVFloatSeq& () { return *_pd_seq; }
#endif
      
    inline const VHVFloatSeq& in() const { return *_pd_seq; }
    inline VHVFloatSeq&       inout()    { return *_pd_seq; }
    inline VHVFloatSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline VHVFloatSeq* _retn() { VHVFloatSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class VHVFloatSeq_out;
    
  private:
    VHVFloatSeq* _pd_seq;
  };

  class VHVFloatSeq_out {
  public:
    inline VHVFloatSeq_out(VHVFloatSeq*& _s) : _data(_s) { _data = 0; }
    inline VHVFloatSeq_out(VHVFloatSeq_var& _s)
      : _data(_s._pd_seq) { _s = (VHVFloatSeq*) 0; }
    inline VHVFloatSeq_out(const VHVFloatSeq_out& _s) : _data(_s._data) {}
    inline VHVFloatSeq_out& operator = (const VHVFloatSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline VHVFloatSeq_out& operator = (VHVFloatSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator VHVFloatSeq*&()  { return _data; }
    inline VHVFloatSeq*& ptr()       { return _data; }
    inline VHVFloatSeq* operator->() { return _data; }

    inline ::CORBA::Float& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    VHVFloatSeq*& _data;

  private:
    VHVFloatSeq_out();
    VHVFloatSeq_out& operator=(const VHVFloatSeq_var&);
  };

  class VHVBoolSeq_var;

  class VHVBoolSeq : public _CORBA_Unbounded_Sequence_Boolean {
  public:
    typedef VHVBoolSeq_var _var_type;
    inline VHVBoolSeq() {}
    inline VHVBoolSeq(const VHVBoolSeq& _s)
      : _CORBA_Unbounded_Sequence_Boolean(_s) {}

    inline VHVBoolSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Boolean(_max) {}
    inline VHVBoolSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Boolean* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Boolean(_max, _len, _val, _rel) {}

  

    inline VHVBoolSeq& operator = (const VHVBoolSeq& _s) {
      _CORBA_Unbounded_Sequence_Boolean::operator=(_s);
      return *this;
    }
  };

  class VHVBoolSeq_out;

  class VHVBoolSeq_var {
  public:
    inline VHVBoolSeq_var() : _pd_seq(0) {}
    inline VHVBoolSeq_var(VHVBoolSeq* _s) : _pd_seq(_s) {}
    inline VHVBoolSeq_var(const VHVBoolSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new VHVBoolSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~VHVBoolSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline VHVBoolSeq_var& operator = (VHVBoolSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline VHVBoolSeq_var& operator = (const VHVBoolSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new VHVBoolSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Boolean& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline VHVBoolSeq* operator -> () { return _pd_seq; }
    inline const VHVBoolSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator VHVBoolSeq& () const { return *_pd_seq; }
#else
    inline operator const VHVBoolSeq& () const { return *_pd_seq; }
    inline operator VHVBoolSeq& () { return *_pd_seq; }
#endif
      
    inline const VHVBoolSeq& in() const { return *_pd_seq; }
    inline VHVBoolSeq&       inout()    { return *_pd_seq; }
    inline VHVBoolSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline VHVBoolSeq* _retn() { VHVBoolSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class VHVBoolSeq_out;
    
  private:
    VHVBoolSeq* _pd_seq;
  };

  class VHVBoolSeq_out {
  public:
    inline VHVBoolSeq_out(VHVBoolSeq*& _s) : _data(_s) { _data = 0; }
    inline VHVBoolSeq_out(VHVBoolSeq_var& _s)
      : _data(_s._pd_seq) { _s = (VHVBoolSeq*) 0; }
    inline VHVBoolSeq_out(const VHVBoolSeq_out& _s) : _data(_s._data) {}
    inline VHVBoolSeq_out& operator = (const VHVBoolSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline VHVBoolSeq_out& operator = (VHVBoolSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator VHVBoolSeq*&()  { return _data; }
    inline VHVBoolSeq*& ptr()       { return _data; }
    inline VHVBoolSeq* operator->() { return _data; }

    inline ::CORBA::Boolean& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    VHVBoolSeq*& _data;

  private:
    VHVBoolSeq_out();
    VHVBoolSeq_out& operator=(const VHVBoolSeq_var&);
  };

  class VHVShortSeq_var;

  class VHVShortSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 >  {
  public:
    typedef VHVShortSeq_var _var_type;
    inline VHVShortSeq() {}
    inline VHVShortSeq(const VHVShortSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_s) {}

    inline VHVShortSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_max) {}
    inline VHVShortSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Short* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline VHVShortSeq& operator = (const VHVShortSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class VHVShortSeq_out;

  class VHVShortSeq_var {
  public:
    inline VHVShortSeq_var() : _pd_seq(0) {}
    inline VHVShortSeq_var(VHVShortSeq* _s) : _pd_seq(_s) {}
    inline VHVShortSeq_var(const VHVShortSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new VHVShortSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~VHVShortSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline VHVShortSeq_var& operator = (VHVShortSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline VHVShortSeq_var& operator = (const VHVShortSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new VHVShortSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Short& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline VHVShortSeq* operator -> () { return _pd_seq; }
    inline const VHVShortSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator VHVShortSeq& () const { return *_pd_seq; }
#else
    inline operator const VHVShortSeq& () const { return *_pd_seq; }
    inline operator VHVShortSeq& () { return *_pd_seq; }
#endif
      
    inline const VHVShortSeq& in() const { return *_pd_seq; }
    inline VHVShortSeq&       inout()    { return *_pd_seq; }
    inline VHVShortSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline VHVShortSeq* _retn() { VHVShortSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class VHVShortSeq_out;
    
  private:
    VHVShortSeq* _pd_seq;
  };

  class VHVShortSeq_out {
  public:
    inline VHVShortSeq_out(VHVShortSeq*& _s) : _data(_s) { _data = 0; }
    inline VHVShortSeq_out(VHVShortSeq_var& _s)
      : _data(_s._pd_seq) { _s = (VHVShortSeq*) 0; }
    inline VHVShortSeq_out(const VHVShortSeq_out& _s) : _data(_s._data) {}
    inline VHVShortSeq_out& operator = (const VHVShortSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline VHVShortSeq_out& operator = (VHVShortSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator VHVShortSeq*&()  { return _data; }
    inline VHVShortSeq*& ptr()       { return _data; }
    inline VHVShortSeq* operator->() { return _data; }

    inline ::CORBA::Short& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    VHVShortSeq*& _data;

  private:
    VHVShortSeq_out();
    VHVShortSeq_out& operator=(const VHVShortSeq_var&);
  };

  class VHVUShortSeq_var;

  class VHVUShortSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 >  {
  public:
    typedef VHVUShortSeq_var _var_type;
    inline VHVUShortSeq() {}
    inline VHVUShortSeq(const VHVUShortSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_s) {}

    inline VHVUShortSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max) {}
    inline VHVUShortSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::UShort* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline VHVUShortSeq& operator = (const VHVUShortSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class VHVUShortSeq_out;

  class VHVUShortSeq_var {
  public:
    inline VHVUShortSeq_var() : _pd_seq(0) {}
    inline VHVUShortSeq_var(VHVUShortSeq* _s) : _pd_seq(_s) {}
    inline VHVUShortSeq_var(const VHVUShortSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new VHVUShortSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~VHVUShortSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline VHVUShortSeq_var& operator = (VHVUShortSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline VHVUShortSeq_var& operator = (const VHVUShortSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new VHVUShortSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::UShort& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline VHVUShortSeq* operator -> () { return _pd_seq; }
    inline const VHVUShortSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator VHVUShortSeq& () const { return *_pd_seq; }
#else
    inline operator const VHVUShortSeq& () const { return *_pd_seq; }
    inline operator VHVUShortSeq& () { return *_pd_seq; }
#endif
      
    inline const VHVUShortSeq& in() const { return *_pd_seq; }
    inline VHVUShortSeq&       inout()    { return *_pd_seq; }
    inline VHVUShortSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline VHVUShortSeq* _retn() { VHVUShortSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class VHVUShortSeq_out;
    
  private:
    VHVUShortSeq* _pd_seq;
  };

  class VHVUShortSeq_out {
  public:
    inline VHVUShortSeq_out(VHVUShortSeq*& _s) : _data(_s) { _data = 0; }
    inline VHVUShortSeq_out(VHVUShortSeq_var& _s)
      : _data(_s._pd_seq) { _s = (VHVUShortSeq*) 0; }
    inline VHVUShortSeq_out(const VHVUShortSeq_out& _s) : _data(_s._data) {}
    inline VHVUShortSeq_out& operator = (const VHVUShortSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline VHVUShortSeq_out& operator = (VHVUShortSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator VHVUShortSeq*&()  { return _data; }
    inline VHVUShortSeq*& ptr()       { return _data; }
    inline VHVUShortSeq* operator->() { return _data; }

    inline ::CORBA::UShort& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    VHVUShortSeq*& _data;

  private:
    VHVUShortSeq_out();
    VHVUShortSeq_out& operator=(const VHVUShortSeq_var&);
  };

  class VHVStringSeq_var;

  class VHVStringSeq : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef VHVStringSeq_var _var_type;
    inline VHVStringSeq() {}
    inline VHVStringSeq(const VHVStringSeq& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline VHVStringSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline VHVStringSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline VHVStringSeq& operator = (const VHVStringSeq& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class VHVStringSeq_out;

  class VHVStringSeq_var {
  public:
    inline VHVStringSeq_var() : _pd_seq(0) {}
    inline VHVStringSeq_var(VHVStringSeq* _s) : _pd_seq(_s) {}
    inline VHVStringSeq_var(const VHVStringSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new VHVStringSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~VHVStringSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline VHVStringSeq_var& operator = (VHVStringSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline VHVStringSeq_var& operator = (const VHVStringSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new VHVStringSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline VHVStringSeq* operator -> () { return _pd_seq; }
    inline const VHVStringSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator VHVStringSeq& () const { return *_pd_seq; }
#else
    inline operator const VHVStringSeq& () const { return *_pd_seq; }
    inline operator VHVStringSeq& () { return *_pd_seq; }
#endif
      
    inline const VHVStringSeq& in() const { return *_pd_seq; }
    inline VHVStringSeq&       inout()    { return *_pd_seq; }
    inline VHVStringSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline VHVStringSeq* _retn() { VHVStringSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class VHVStringSeq_out;
    
  private:
    VHVStringSeq* _pd_seq;
  };

  class VHVStringSeq_out {
  public:
    inline VHVStringSeq_out(VHVStringSeq*& _s) : _data(_s) { _data = 0; }
    inline VHVStringSeq_out(VHVStringSeq_var& _s)
      : _data(_s._pd_seq) { _s = (VHVStringSeq*) 0; }
    inline VHVStringSeq_out(const VHVStringSeq_out& _s) : _data(_s._data) {}
    inline VHVStringSeq_out& operator = (const VHVStringSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline VHVStringSeq_out& operator = (VHVStringSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator VHVStringSeq*&()  { return _data; }
    inline VHVStringSeq*& ptr()       { return _data; }
    inline VHVStringSeq* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    VHVStringSeq*& _data;

  private:
    VHVStringSeq_out();
    VHVStringSeq_out& operator=(const VHVStringSeq_var&);
  };

  struct autoParams {
    typedef _CORBA_ConstrType_Fix_Var<autoParams> _var_type;

    
    ::CORBA::Boolean autoEnable;

    ::CORBA::Boolean autoRestoreEnable;

    ::CORBA::Short threshold;

    ::CORBA::Short hiThreshold;

    ::CORBA::Short patternThreshold;

    ::CORBA::Short patternMultiplicity;

    ::CORBA::Float restoreMargin;

    ::CORBA::Float patternRestoreMargin;

    ::CORBA::Short checkTime;

    ::CORBA::Short recentTime;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef autoParams::_var_type autoParams_var;

  typedef autoParams& autoParams_out;

  struct fdbkParams {
    typedef _CORBA_ConstrType_Fix_Var<fdbkParams> _var_type;

    
    ::CORBA::Boolean fFeedbackEnabled;

    ::CORBA::Boolean fOldSchool;

    ::CORBA::Short fThreshold;

    ::CORBA::Short fHiThreshold;

    ::CORBA::Short fPatternThreshold;

    ::CORBA::Short fPatternMultiplicity;

    ::CORBA::Float fRestoreMargin;

    ::CORBA::Short fMeasurementsPerCycle;

    ::CORBA::Short fMinTimeBeforeRestore;

    ::CORBA::Short fNumberOfFeedbackLevels;

    ::CORBA::Float fGainScaling;

    ::CORBA::Float fSafetyFactor;

    ::CORBA::Short fRestoreAttemptTime;

    ::CORBA::Float fMinAbsPositionChange;

    ::CORBA::Float fPatternDistanceDrop;

    ::CORBA::Float fPSF;

    ::CORBA::Short fCyclesPerFeedbackTest;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef fdbkParams::_var_type fdbkParams_var;

  typedef fdbkParams& fdbkParams_out;

#ifndef __VHVCommunications_mVNETTransfer__
#define __VHVCommunications_mVNETTransfer__

  class VNETTransfer;
  class _objref_VNETTransfer;
  class _impl_VNETTransfer;
  
  typedef _objref_VNETTransfer* VNETTransfer_ptr;
  typedef VNETTransfer_ptr VNETTransferRef;

  class VNETTransfer_Helper {
  public:
    typedef VNETTransfer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_VNETTransfer, VNETTransfer_Helper> VNETTransfer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_VNETTransfer,VNETTransfer_Helper > VNETTransfer_out;

#endif

  // interface VNETTransfer
  class VNETTransfer {
  public:
    // Declarations for this interface type.
    typedef VNETTransfer_ptr _ptr_type;
    typedef VNETTransfer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_VNETTransfer :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    void pixelSetVReq(::CORBA::Short pixel, ::CORBA::Float voltage);
    ::CORBA::Float pixelGetVSet(::CORBA::Short pixel);
    ::CORBA::Float pixelGetVReq(::CORBA::Short pixel);
    ::CORBA::Float pixelGetVTrue(::CORBA::Short pixel);
    void allSetHV(::CORBA::Float voltage);
    VHVFloatSeq* allGetVSet();
    VHVFloatSeq* allGetVReq();
    VHVFloatSeq* allGetVTrue();
    void allOffsetHV(::CORBA::Float voltage);
    void allScaleHV(::CORBA::Float percent);
    void writeVoltagesToDB();
    void readVoltagesFromDB();
    void allOn();
    void allOff();
    VHVBoolSeq* allGetPowerStatus();
    ::CORBA::Boolean pixelGetPowerStatus(::CORBA::Short pixel);
    void pixelOn(::CORBA::Short pixel);
    void pixelOff(::CORBA::Short pixel);
    void pixelSuppress(::CORBA::Short pixel);
    void pixelRestore(::CORBA::Short pixel);
    void allSuppress();
    void allRestore();
    void restoreRecent();
    ::CORBA::Boolean pixelGetSuppressionStatus(::CORBA::Short pixel);
    VHVBoolSeq* allGetSuppressionStatus();
    void loggingOn();
    void loggingOff();
    ::CORBA::Boolean getLoggingState();
    void alive();
    void quitVHV();
    void connectToHVAC();
    void disconnectFromHVAC();
    void markPixelDisabled(::CORBA::Short pixel);
    void unmarkPixelDisabled(::CORBA::Short pixel);
    ::CORBA::Boolean pixelGetDisabledStatus(::CORBA::Short pixel);
    VHVBoolSeq* allGetDisabledStatus();
    void markPixelNoAuto(::CORBA::Short pixel);
    void unmarkPixelNoAuto(::CORBA::Short pixel);
    ::CORBA::Boolean pixelGetAutoStatus(::CORBA::Short pixel);
    VHVBoolSeq* allGetAutoStatus();
    void setAutoResponseParams(const ::VHVCommunications::autoParams& params);
    autoParams getAutoResponseParams();
    void setFeedbackParams(const ::VHVCommunications::fdbkParams& params);
    fdbkParams getFeedbackParams();
    void setTelescopeTarget(::CORBA::Short targetIndex);
    void setRA(::CORBA::Float ra);
    void setDec(::CORBA::Float dec);
    void takeStarControl();
    void releaseStarControl();
    ::CORBA::Short getNumberOfPMTs();
    ::CORBA::Short getNumberOfBoards();
    ::CORBA::Short getNumberOfCrates();
    ::CORBA::Boolean getCrateStatus(::CORBA::Short crate);
    VHVShortSeq* getHVCrate();
    VHVShortSeq* getHVSlot();
    VHVShortSeq* getHVChannel();
    VHVShortSeq* getStatus();
    VHVFloatSeq* getCurrent();
    VHVShortSeq* getBoardCrate();
    VHVShortSeq* getBoardSlot();
    VHVFloatSeq* getBoardVSet();
    VHVFloatSeq* getBoardVReq();
    VHVUShortSeq* getHWStatus();
    void setBoardVReq(::CORBA::Short board, ::CORBA::Float voltage);
    VHVFloatSeq* getBoardVTrue();
    VHVFloatSeq* getBoardVMax();
    VHVBoolSeq* getBoardPower();
    void setBoardPower(::CORBA::Short board, ::CORBA::Boolean powerState);
    void setAllBoardPower(::CORBA::Boolean powerState);
    VHVShortSeq* getBoardRampUp();
    VHVShortSeq* getBoardRampDown();
    void setBoardRampUp(::CORBA::Short board, ::CORBA::Short ramp);
    void setAllBoardRampUp(::CORBA::Short ramp);
    void setBoardRampDown(::CORBA::Short board, ::CORBA::Short ramp);
    void setAllBoardRampDown(::CORBA::Short ramp);
    VHVFloatSeq* getBoardIMax();
    void setBoardIMax(::CORBA::Short board, ::CORBA::Float iMax);
    void setAllBoardIMax(::CORBA::Float iMax);
    VHVFloatSeq* getBoardCurrent();
    VHVFloatSeq* getBoardTemp();
    VHVBoolSeq* getBoardActive();
    void setBoardActive(::CORBA::Short board, ::CORBA::Boolean active);
    void setAllBoardActive(::CORBA::Boolean active);
    ::CORBA::Short getCurrentsStatus();
    ::CORBA::Short getCameraTemp();
    ::CORBA::Short getCameraHum();
    ::CORBA::Short getSensor(::CORBA::Short id);
    VHVStringSeq* getMessages();
    void globalFeedbackReset();
    void pixelFeedbackReset(::CORBA::Short ch);
    void globalFeedbackOn();
    void pixelFeedbackOn(::CORBA::Short ch);
    void globalFeedbackOff();
    void pixelFeedbackOff(::CORBA::Short ch);
    void globalRefreshVoltageLevels();
    ::CORBA::Boolean isGlobalFeedbackEnabled();
    ::CORBA::Boolean isPixelFeedbackEnabled(::CORBA::Short ch);
    VHVBoolSeq* isAllPixelFeedbackEnabled();
    VHVShortSeq* getFeedbackLevel();
    ::CORBA::Short getStatusPeriod();
    void setStatusPeriod(::CORBA::Short period);
    ::CORBA::Boolean getStateLimitBoardVoltages();
    void enableLimitBoardVoltages();
    void disableLimitBoardVoltages();
    ::CORBA::Short getHVStatus();
    void setPixelStatus(::CORBA::Short pixel, ::CORBA::Short status);

    inline _objref_VNETTransfer()  { _PR_setobj(0); }  // nil
    _objref_VNETTransfer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_VNETTransfer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_VNETTransfer(const _objref_VNETTransfer&);
    _objref_VNETTransfer& operator = (const _objref_VNETTransfer&);
    // not implemented

    friend class VNETTransfer;
  };

  class _pof_VNETTransfer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_VNETTransfer() : _OMNI_NS(proxyObjectFactory)(VNETTransfer::_PD_repoId) {}
    virtual ~_pof_VNETTransfer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_VNETTransfer :
    public virtual omniServant
  {
  public:
    virtual ~_impl_VNETTransfer();

    virtual void pixelSetVReq(::CORBA::Short pixel, ::CORBA::Float voltage) = 0;
    virtual ::CORBA::Float pixelGetVSet(::CORBA::Short pixel) = 0;
    virtual ::CORBA::Float pixelGetVReq(::CORBA::Short pixel) = 0;
    virtual ::CORBA::Float pixelGetVTrue(::CORBA::Short pixel) = 0;
    virtual void allSetHV(::CORBA::Float voltage) = 0;
    virtual VHVFloatSeq* allGetVSet() = 0;
    virtual VHVFloatSeq* allGetVReq() = 0;
    virtual VHVFloatSeq* allGetVTrue() = 0;
    virtual void allOffsetHV(::CORBA::Float voltage) = 0;
    virtual void allScaleHV(::CORBA::Float percent) = 0;
    virtual void writeVoltagesToDB() = 0;
    virtual void readVoltagesFromDB() = 0;
    virtual void allOn() = 0;
    virtual void allOff() = 0;
    virtual VHVBoolSeq* allGetPowerStatus() = 0;
    virtual ::CORBA::Boolean pixelGetPowerStatus(::CORBA::Short pixel) = 0;
    virtual void pixelOn(::CORBA::Short pixel) = 0;
    virtual void pixelOff(::CORBA::Short pixel) = 0;
    virtual void pixelSuppress(::CORBA::Short pixel) = 0;
    virtual void pixelRestore(::CORBA::Short pixel) = 0;
    virtual void allSuppress() = 0;
    virtual void allRestore() = 0;
    virtual void restoreRecent() = 0;
    virtual ::CORBA::Boolean pixelGetSuppressionStatus(::CORBA::Short pixel) = 0;
    virtual VHVBoolSeq* allGetSuppressionStatus() = 0;
    virtual void loggingOn() = 0;
    virtual void loggingOff() = 0;
    virtual ::CORBA::Boolean getLoggingState() = 0;
    virtual void alive() = 0;
    virtual void quitVHV() = 0;
    virtual void connectToHVAC() = 0;
    virtual void disconnectFromHVAC() = 0;
    virtual void markPixelDisabled(::CORBA::Short pixel) = 0;
    virtual void unmarkPixelDisabled(::CORBA::Short pixel) = 0;
    virtual ::CORBA::Boolean pixelGetDisabledStatus(::CORBA::Short pixel) = 0;
    virtual VHVBoolSeq* allGetDisabledStatus() = 0;
    virtual void markPixelNoAuto(::CORBA::Short pixel) = 0;
    virtual void unmarkPixelNoAuto(::CORBA::Short pixel) = 0;
    virtual ::CORBA::Boolean pixelGetAutoStatus(::CORBA::Short pixel) = 0;
    virtual VHVBoolSeq* allGetAutoStatus() = 0;
    virtual void setAutoResponseParams(const ::VHVCommunications::autoParams& params) = 0;
    virtual autoParams getAutoResponseParams() = 0;
    virtual void setFeedbackParams(const ::VHVCommunications::fdbkParams& params) = 0;
    virtual fdbkParams getFeedbackParams() = 0;
    virtual void setTelescopeTarget(::CORBA::Short targetIndex) = 0;
    virtual void setRA(::CORBA::Float ra) = 0;
    virtual void setDec(::CORBA::Float dec) = 0;
    virtual void takeStarControl() = 0;
    virtual void releaseStarControl() = 0;
    virtual ::CORBA::Short getNumberOfPMTs() = 0;
    virtual ::CORBA::Short getNumberOfBoards() = 0;
    virtual ::CORBA::Short getNumberOfCrates() = 0;
    virtual ::CORBA::Boolean getCrateStatus(::CORBA::Short crate) = 0;
    virtual VHVShortSeq* getHVCrate() = 0;
    virtual VHVShortSeq* getHVSlot() = 0;
    virtual VHVShortSeq* getHVChannel() = 0;
    virtual VHVShortSeq* getStatus() = 0;
    virtual VHVFloatSeq* getCurrent() = 0;
    virtual VHVShortSeq* getBoardCrate() = 0;
    virtual VHVShortSeq* getBoardSlot() = 0;
    virtual VHVFloatSeq* getBoardVSet() = 0;
    virtual VHVFloatSeq* getBoardVReq() = 0;
    virtual VHVUShortSeq* getHWStatus() = 0;
    virtual void setBoardVReq(::CORBA::Short board, ::CORBA::Float voltage) = 0;
    virtual VHVFloatSeq* getBoardVTrue() = 0;
    virtual VHVFloatSeq* getBoardVMax() = 0;
    virtual VHVBoolSeq* getBoardPower() = 0;
    virtual void setBoardPower(::CORBA::Short board, ::CORBA::Boolean powerState) = 0;
    virtual void setAllBoardPower(::CORBA::Boolean powerState) = 0;
    virtual VHVShortSeq* getBoardRampUp() = 0;
    virtual VHVShortSeq* getBoardRampDown() = 0;
    virtual void setBoardRampUp(::CORBA::Short board, ::CORBA::Short ramp) = 0;
    virtual void setAllBoardRampUp(::CORBA::Short ramp) = 0;
    virtual void setBoardRampDown(::CORBA::Short board, ::CORBA::Short ramp) = 0;
    virtual void setAllBoardRampDown(::CORBA::Short ramp) = 0;
    virtual VHVFloatSeq* getBoardIMax() = 0;
    virtual void setBoardIMax(::CORBA::Short board, ::CORBA::Float iMax) = 0;
    virtual void setAllBoardIMax(::CORBA::Float iMax) = 0;
    virtual VHVFloatSeq* getBoardCurrent() = 0;
    virtual VHVFloatSeq* getBoardTemp() = 0;
    virtual VHVBoolSeq* getBoardActive() = 0;
    virtual void setBoardActive(::CORBA::Short board, ::CORBA::Boolean active) = 0;
    virtual void setAllBoardActive(::CORBA::Boolean active) = 0;
    virtual ::CORBA::Short getCurrentsStatus() = 0;
    virtual ::CORBA::Short getCameraTemp() = 0;
    virtual ::CORBA::Short getCameraHum() = 0;
    virtual ::CORBA::Short getSensor(::CORBA::Short id) = 0;
    virtual VHVStringSeq* getMessages() = 0;
    virtual void globalFeedbackReset() = 0;
    virtual void pixelFeedbackReset(::CORBA::Short ch) = 0;
    virtual void globalFeedbackOn() = 0;
    virtual void pixelFeedbackOn(::CORBA::Short ch) = 0;
    virtual void globalFeedbackOff() = 0;
    virtual void pixelFeedbackOff(::CORBA::Short ch) = 0;
    virtual void globalRefreshVoltageLevels() = 0;
    virtual ::CORBA::Boolean isGlobalFeedbackEnabled() = 0;
    virtual ::CORBA::Boolean isPixelFeedbackEnabled(::CORBA::Short ch) = 0;
    virtual VHVBoolSeq* isAllPixelFeedbackEnabled() = 0;
    virtual VHVShortSeq* getFeedbackLevel() = 0;
    virtual ::CORBA::Short getStatusPeriod() = 0;
    virtual void setStatusPeriod(::CORBA::Short period) = 0;
    virtual ::CORBA::Boolean getStateLimitBoardVoltages() = 0;
    virtual void enableLimitBoardVoltages() = 0;
    virtual void disableLimitBoardVoltages() = 0;
    virtual ::CORBA::Short getHVStatus() = 0;
    virtual void setPixelStatus(::CORBA::Short pixel, ::CORBA::Short status) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_VHVCommunications
_CORBA_MODULE_BEG

  class VNETTransfer :
    public virtual VHVCommunications::_impl_VNETTransfer,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~VNETTransfer();

    inline ::VHVCommunications::VNETTransfer_ptr _this() {
      return (::VHVCommunications::VNETTransfer_ptr) _do_this(::VHVCommunications::VNETTransfer::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_VHVCommunications
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
VHVCommunications::VNETTransfer::_marshalObjRef(::VHVCommunications::VNETTransfer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_VNETFunctions
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_VNETFunctions
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_VNETFunctions
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_VNETFunctions
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_VNETFunctions
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_VNETFunctions
#endif

#endif  // __VNETFunctions_hh__

