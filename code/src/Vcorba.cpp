// "@(#) Vcorba  1.5"
// DO NOT EDIT THIS FILE. It was generated on
// Fri Apr  8 11:32:49 IST 2005 from
// Vcorba.cpp
// Marty Olevitch, Feb '04

#include "Vcorba.h"
#include <iostream>
#include <sstream>

#include <time.h>	// nanosleep, timespec

namespace {
    char VcorbaVersionString[] = "@(#) Vcorba  1.5";

    CORBA::ORB_var Orb = CORBA::ORB::_nil();
    CosNaming::NamingContext_var RootContext =
    	CosNaming::NamingContext::_nil();
    PortableServer::POA_var Vcorba::corba_server::Poa =
    	PortableServer::POA::_nil();

    int fake_argc = 3;
    char *fake_argv[3] = {
	"Vcorba" ,
    	"-ORBInitRef",
	""		// filled in by contructor
    };

    void
    set_fake_argv_hostname(std::string& hostname)
    {
	if (hostname.length() == 0) {
	    fake_argc = 1;
	} else {
	    std::string tmpstr = "NameService=corbaname::";
	    tmpstr += hostname;
	    fake_argv[2] = const_cast<char *>(tmpstr.c_str());
	    //std::cout << "[" << fake_argv[2] << "]" <<  "\n";
	}
    }

}	// end of anonymous namespace

namespace Vcorba {

    std::string
    version()
    {
	return VcorbaVersionString;
    }

    corba_server::corba_server(std::string& hostname)
	throw (VcorbaException)
    {
	try {

	    set_fake_argv_hostname(hostname);
	    server_init(fake_argc, fake_argv);

	} catch (VException &e) {
	    V_RETHROW(e);
	}
    }

    corba_server::corba_server(int& argc, char *argv[])
	throw (VcorbaException)
    {
	try {

	    server_init(argc, argv);

	} catch (VException &e) {
	    V_RETHROW(e);
	}
    }

    void
    corba_server::
    server_init(int& argc, char *argv[])
	throw (VcorbaException)
    {
	try {
	    if (CORBA::is_nil(Orb)) {
		Orb = CORBA::ORB_init(argc, argv);
		V_ASSERT(!CORBA::is_nil(Orb));
	    }

	    PortableServer::POAManager_var poa_man;

	    // get top-level object zone
	    CORBA::Object_var obj = Orb->resolve_initial_references("RootPOA");
	    Poa = PortableServer::POA::_narrow(obj);

	    // get the manager for the object zone and activate it
	    poa_man = Poa->the_POAManager();
	    poa_man->activate();

	} catch (VException &e) {
	    V_RETHROW(e);
	} catch (CORBA::Exception &e) {
	    V_THROW(VcorbaException, string_from_corba_exception(e));
	} catch (omniORB::fatalException &e) {
	    V_THROW(VcorbaException, "omniORB::fatalException");
	} catch (...) {
	    V_THROW(VcorbaException, "Unknown exception.");
	}
    }

    corba_server::
    ~corba_server()
    {
	if (!CORBA::is_nil(Orb)) {
	    Orb->destroy();
	    Orb = CORBA::ORB::_nil();
	}
    }

    void
    corba_server::run()
	throw (VcorbaException)
    {
	try {
	    if (!CORBA::is_nil(Orb)) {
		Orb->run();
	    }
	} catch (CORBA::Exception &e) {
	    V_THROW(VcorbaException, string_from_corba_exception(e));
	} catch (...) {
	    V_THROW(VcorbaException, "Unknown exception.");
	}
    }

    void
    corba_server::
    shutdown(bool waitFlag)
	throw (VcorbaException)
    {
	try {
	    if (!CORBA::is_nil(Orb)) {
		Orb->shutdown(waitFlag);
	    }
	} catch (CORBA::Exception &e) {
	    V_THROW(VcorbaException, string_from_corba_exception(e));
	} catch (...) {
	    V_THROW(VcorbaException, "Unknown exception.");
	}
    }

    void
    corba_server::registerObj(CORBA::Object_var comms_obj,
	    const char *progName, const char *objName)
	throw (VcorbaException)
    {
	std::ostringstream os("corba_server::registerObj ", std::ios::ate);
	os << "[" << progName << " " << objName << "] ";
	try {
	    try {
		if (CORBA::is_nil(RootContext)) {
		    CORBA::Object_var obj;
		    obj = Orb->resolve_initial_references("NameService");
		    V_ASSERT(!CORBA::is_nil(obj));
		    RootContext = CosNaming::NamingContext::_narrow(obj);
		    V_ASSERT(!CORBA::is_nil(RootContext));
		}
	    } catch (CORBA::ORB::InvalidName &e) {
		V_THROW(VcorbaException,
		    os.str() + "Can't find CORBA name service.");
	    } catch (...) {
		// Handle this exception below.
		throw;
	    }

	    // bind the VERITAS context
	    CosNaming::Name v_ctx_name;
	    v_ctx_name.length(1);
	    v_ctx_name[0].id=(const char*)"VERITAS";
	    v_ctx_name[0].kind=(const char*)"";

	    CosNaming::NamingContext_var v_ctx;
	    try {
		v_ctx=RootContext->bind_new_context(v_ctx_name);
	    } catch (CosNaming::NamingContext::AlreadyBound &e) {
		CORBA::Object_var obj;
		obj=RootContext->resolve(v_ctx_name);
		v_ctx=CosNaming::NamingContext::_narrow(obj);
	    }

	    // bind the VERITAS/Server.Program context
	    CosNaming::Name serv_ctx_name;
	    serv_ctx_name.length(1);
	    serv_ctx_name[0].id= progName;
	    serv_ctx_name[0].kind=(const char*)"Program";

	    CosNaming::NamingContext_var serv_ctx;
	    try {
		serv_ctx=v_ctx->bind_new_context(serv_ctx_name);
	    } catch (CosNaming::NamingContext::AlreadyBound &e) {
		CORBA::Object_var obj;
		obj=v_ctx->resolve(serv_ctx_name);
		serv_ctx=CosNaming::NamingContext::_narrow(obj);
	    }

	    // bind to VERITAS/progName.Program/objName.Object
	    CosNaming::Name comms_name;
	    comms_name.length(1);
	    comms_name[0].id= objName;
	    comms_name[0].kind=(const char*)"Object";

	    try {
		serv_ctx->bind(comms_name,comms_obj);
	    } catch (CosNaming::NamingContext::AlreadyBound &e) {
		serv_ctx->rebind(comms_name,comms_obj);
	    }
	} catch (CORBA::Exception &e) {
	    V_THROW(VcorbaException, os.str() + string_from_corba_exception(e));
	} catch (omniORB::fatalException &e) {
	    V_THROW(VcorbaException, os.str() + "omniORB::fatalException");
	} catch (VException &e) {
	    V_RETHROW(e);
	} catch (...) {
	    V_THROW(VcorbaException, os.str() + "Unknown exception.");
	}
    }

    corba_client::corba_client(std::string& hostname)
	throw (VcorbaException)
    {
	set_fake_argv_hostname(hostname);
	client_init(fake_argc, fake_argv);
    }

    corba_client::corba_client(int& argc, char *argv[])
	throw (VcorbaException)
    {
	client_init(argc, argv);
    }

    void
    corba_client::
    client_init(int& argc, char *argv[])
	throw (VcorbaException)
    {
	try {
	    if (CORBA::is_nil(Orb)) {
		Orb = CORBA::ORB_init(argc, argv);
		V_ASSERT(!CORBA::is_nil(Orb));
	    }
	    try {
		if (CORBA::is_nil(RootContext)) {
		    CORBA::Object_var obj;
		    obj = Orb->resolve_initial_references("NameService");
		    V_ASSERT(!CORBA::is_nil(obj));
		    RootContext = CosNaming::NamingContext::_narrow(obj);
		    V_ASSERT(!CORBA::is_nil(RootContext));
		}
	    } catch (CORBA::ORB::InvalidName &e) {
		V_THROW(VcorbaException, "Can't find CORBA name service.");
	    } catch (...) {
		throw;
	    }
	} catch (CORBA::Exception &e) {
	    V_THROW(VcorbaException, string_from_corba_exception(e));
	} catch (VException &e) {
	    V_RETHROW(e);
	} catch (omniORB::fatalException &e) {
	    V_THROW(VcorbaException, "omniORB::fatalException");
	} catch (...) {
	    V_THROW(VcorbaException, "Unknown exception.");
	}
    }

    CORBA::Object_var
    corba_client::
    getObjectRef(const char* progName, const char *objName, int timeoutSec)
	throw (VcorbaException)
    {
	int timeWaited = 0;

	do {
	    CosNaming::Name name;
	    name.length(3);
	    name[0].id = (const char*)"VERITAS";
	    name[0].kind = (const char*)"";
	    name[1].id = progName;
	    name[1].kind = (const char*)"Program";
	    name[2].id = objName;
	    name[2].kind = (const char*)"Object";

	    CORBA::Object_var obj;

	    try {

		obj = RootContext->resolve(name);

		// _non_existent() can throw an exception in certain cases,
		// or it can indicate a "dangling reference" which should
		// be removed. In either case, we pause.
		if (obj->_non_existent()) {
		    // Should unbind the dangling reference here?
		    throw 0; // Should be caught below.
		}

		return obj;

	    } catch (...) {
		// Pause for a second, then try again unless we've being
		// doing this too long.
		struct timespec t;
		t.tv_sec = 1;
		t.tv_nsec = 0;
		nanosleep(&t, NULL);
	    }

	    timeWaited++;

	} while (timeoutSec < 0 || timeWaited < timeoutSec);

	// Waited too long.
	V_THROW(VcorbaException, "Timed out waiting for object reference.");
    }

    // ostream operator<< for corba exceptions
    // From Henning and Vinoski, "Advanced CORBA Programming with C++", p. 321
    std::ostream &
    operator<<(std::ostream& os, const CORBA::Exception& e)
    {
	CORBA::Any tmp;
	tmp <<= e;
	CORBA::TypeCode_var tc = tmp.type();
	const char* p = tc->name();
	if (*p != '\0') {
	    os << p;
	    if (std::strcmp(tc->name(), "COMM_FAILURE") == 0) {
		os << std::endl
		    << " (can't contact object; maybe nameserver unavailable).";
	    } else if (std::strcmp(tc->name(), "TRANSIENT") == 0) {
		os << std::endl
		    << " (can't contact object for some reason or other).";
	    }
	    // Can add more special case for other corba exceptions here.
	} else {
	    os << tc->id();
	}
	return os;
    }

    // string_from_corba_exception() - returns the text of the corba excep.
    std::string
    string_from_corba_exception(CORBA::Exception &e)
    {
	std::ostringstream ost;
	ost << "CORBA::Exception " << e;
	return ost.str();
    }

}	// namespace Vcorba
